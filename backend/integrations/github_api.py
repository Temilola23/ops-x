"""
GitHub API Integration
Handles repo creation, branches, commits, and PRs
"""

import os
import base64
import httpx
from typing import Dict, List, Optional


class GitHubAPIClient:
    """GitHub REST API client"""
    
    def __init__(self):
        self.token = os.getenv("GITHUB_TOKEN", "")
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {self.token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
        }
        
        if not self.token:
            print("WARNING: GITHUB_TOKEN not found in environment")
        else:
            print(f"GitHub client initialized with token: {self.token[:8]}...")
    
    async def create_repo(self, name: str, description: str, private: bool = False) -> Dict:
        """Create a new GitHub repository"""
        
        # Add timestamp to ensure unique repo names
        from datetime import datetime
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        unique_name = f"{name}-{timestamp}"
        
        # 30 second timeout for repo creation
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                f"{self.base_url}/user/repos",
                headers=self.headers,
                json={
                    "name": unique_name,
                    "description": description,
                    "private": private,
                    "auto_init": False  # Don't wait for README - we're pushing files anyway
                }
            )
            
            if response.status_code == 201:
                repo_data = response.json()
                print(f"GitHub repo created successfully: {repo_data['html_url']}")
                return {
                    "success": True,
                    "repo_name": repo_data["full_name"],
                    "repo_url": repo_data["html_url"],
                    "clone_url": repo_data["clone_url"],
                    "default_branch": repo_data["default_branch"]
                }
            else:
                error_msg = f"GitHub API error {response.status_code}: {response.text}"
                print(f"ERROR creating repo: {error_msg}")
                return {
                    "success": False,
                    "error": error_msg
                }
    
    async def initialize_empty_repo(self, repo_full_name: str) -> Dict:
        """Initialize an empty repo with a minimal README"""
        
        print(f"Initializing empty repo {repo_full_name} with README...")
        
        try:
            result = await self.create_or_update_file(
                repo_full_name=repo_full_name,
                file_path="README.md",
                content=f"# {repo_full_name.split('/')[-1]}\n\nGenerated by OPS-X",
                message="Initial commit",
                branch="main"
            )
            
            if result["success"]:
                print(f"✓ Repo initialized")
                return {"success": True}
            else:
                print(f"⚠ Failed to initialize repo: {result.get('error')}")
                return {"success": False, "error": result.get("error")}
        except Exception as e:
            print(f"⚠ Exception initializing repo: {str(e)}")
            return {"success": False, "error": str(e)}
    
    async def get_default_branch_sha(self, repo_full_name: str) -> Optional[str]:
        """Get the SHA of the default branch"""
        
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(
                f"{self.base_url}/repos/{repo_full_name}/git/refs/heads/main",
                headers=self.headers
            )
            
            if response.status_code == 200:
                return response.json()["object"]["sha"]
            
            # Try 'master' if 'main' doesn't exist
            response = await client.get(
                f"{self.base_url}/repos/{repo_full_name}/git/refs/heads/master",
                headers=self.headers
            )
            
            if response.status_code == 200:
                return response.json()["object"]["sha"]
            
            return None
    
    async def create_or_update_file(
        self, 
        repo_full_name: str,
        file_path: str,
        content: str,
        message: str,
        branch: str = "main"
    ) -> Dict:
        """Create or update a file in the repository"""
        
        # Encode content to base64
        content_bytes = content.encode('utf-8')
        content_base64 = base64.b64encode(content_bytes).decode('utf-8')
        
        # 20 second timeout per file operation
        async with httpx.AsyncClient(timeout=20.0) as client:
            # Check if file exists
            get_response = await client.get(
                f"{self.base_url}/repos/{repo_full_name}/contents/{file_path}",
                headers=self.headers,
                params={"ref": branch}
            )
            
            payload = {
                "message": message,
                "content": content_base64,
                "branch": branch
            }
            
            # If file exists, include its SHA for update
            if get_response.status_code == 200:
                existing_sha = get_response.json()["sha"]
                payload["sha"] = existing_sha
            
            # Create or update the file
            response = await client.put(
                f"{self.base_url}/repos/{repo_full_name}/contents/{file_path}",
                headers=self.headers,
                json=payload
            )
            
            if response.status_code in [200, 201]:
                return {
                    "success": True,
                    "commit_sha": response.json()["commit"]["sha"]
                }
            else:
                return {
                    "success": False,
                    "error": f"Failed to create/update file: {response.text}"
                }
    
    async def create_branch(
        self,
        repo_full_name: str,
        branch_name: str,
        base_branch: str = "main"
    ) -> Dict:
        """
        Create a new branch from a base branch
        
        Args:
            repo_full_name: Repository in format "username/repo-name"
            branch_name: Name for the new branch
            base_branch: Branch to create from (default: main)
        """
        async with httpx.AsyncClient() as client:
            # First, get the SHA of the base branch
            ref_response = await client.get(
                f"{self.base_url}/repos/{repo_full_name}/git/ref/heads/{base_branch}",
                headers=self.headers,
                timeout=10.0
            )
            
            if ref_response.status_code != 200:
                return {
                    "success": False,
                    "error": f"Base branch '{base_branch}' not found"
                }
            
            base_sha = ref_response.json()["object"]["sha"]
            print(f"Base branch '{base_branch}' SHA: {base_sha}")
            
            # Create new branch
            response = await client.post(
                f"{self.base_url}/repos/{repo_full_name}/git/refs",
                headers=self.headers,
                json={
                    "ref": f"refs/heads/{branch_name}",
                    "sha": base_sha
                },
                timeout=10.0
            )
            
            if response.status_code == 201:
                print(f"✓ Created branch: {branch_name}")
                return {"success": True, "branch_name": branch_name}
            else:
                return {
                    "success": False,
                    "error": f"Failed to create branch: {response.text}"
                }
    
    async def push_multiple_files(
        self,
        repo_full_name: str,
        files: Dict[str, str],
        commit_message: str,
        branch: str = "main"
    ) -> Dict:
        """Push multiple files to a repository"""
        
        print(f"\nPushing {len(files)} files to {repo_full_name}...")
        results = []
        failed_files = []
        
        for i, (file_path, content) in enumerate(files.items(), 1):
            print(f"  [{i}/{len(files)}] Pushing {file_path}...")
            
            try:
                result = await self.create_or_update_file(
                    repo_full_name,
                    file_path,
                    content,
                    commit_message,
                    branch
                )
                
                if result["success"]:
                    print(f"    ✓ {file_path}")
                else:
                    print(f"    ✗ {file_path}: {result.get('error', 'Unknown error')}")
                    failed_files.append(file_path)
                
                results.append({
                    "file": file_path,
                    "success": result["success"]
                })
            except Exception as e:
                print(f"    ✗ {file_path}: Exception - {str(e)}")
                failed_files.append(file_path)
                results.append({
                    "file": file_path,
                    "success": False,
                    "error": str(e)
                })
        
        all_successful = all(r["success"] for r in results)
        
        if all_successful:
            print(f"✓ Successfully pushed all {len(files)} files!")
        else:
            print(f"⚠ Pushed {len(files) - len(failed_files)}/{len(files)} files. Failed: {failed_files}")
        
        return {
            "success": all_successful,
            "results": results,
            "failed_files": failed_files
        }
    
    async def fetch_repo_files(
        self,
        repo_full_name: str,
        branch: str = "main"
    ) -> Dict[str, str]:
        """
        Fetch all files from a GitHub repository
        
        Args:
            repo_full_name: Repository in format "username/repo-name"  
            branch: Branch to fetch from (default: main)
        
        Returns:
            Dict of {file_path: file_content}
        """
        files = {}
        
        print(f"Fetching files from {repo_full_name} (branch: {branch})")
        
        async with httpx.AsyncClient() as client:
            # Step 1: Get repo info to find default branch
            repo_response = await client.get(
                f"{self.base_url}/repos/{repo_full_name}",
                headers=self.headers,
                timeout=10.0
            )
            
            if repo_response.status_code != 200:
                print(f"❌ Repo not found: {repo_response.status_code}")
                print(f"   Repo: {repo_full_name}")
                return files
            
            repo_data = repo_response.json()
            actual_branch = repo_data.get("default_branch", branch)
            print(f"✓ Repo found. Default branch: {actual_branch}")
            
            # Step 2: Recursively fetch directory contents
            async def fetch_directory(path: str = ""):
                try:
                    url = f"{self.base_url}/repos/{repo_full_name}/contents/{path}?ref={actual_branch}"
                    print(f"Fetching: {url}")
                    
                    contents_response = await client.get(
                        url,
                        headers=self.headers,
                        timeout=15.0
                    )
                    
                    if contents_response.status_code != 200:
                        print(f"Failed to fetch '{path}': {contents_response.status_code}")
                        return
                    
                    items = contents_response.json()
                    if not isinstance(items, list):
                        items = [items]
                    
                    print(f"Found {len(items)} items in '{path or 'root'}'")
                    
                    for item in items:
                        if item["type"] == "file":
                            # Skip binary files
                            if any(item["name"].endswith(ext) for ext in ['.png', '.jpg', '.jpeg', '.gif', '.ico', '.woff', '.woff2', '.ttf', '.eot', '.svg']):
                                continue
                            
                            # Fetch file content individually (GitHub doesn't include content in directory listings)
                            try:
                                file_response = await client.get(
                                    f"{self.base_url}/repos/{repo_full_name}/contents/{item['path']}?ref={actual_branch}",
                                    headers=self.headers,
                                    timeout=10.0
                                )
                                
                                if file_response.status_code == 200:
                                    file_data = file_response.json()
                                    import base64
                                    content = base64.b64decode(file_data["content"]).decode('utf-8')
                                    files[item["path"]] = content
                                    print(f"  ✓ {item['path']}")
                                else:
                                    print(f"  ✗ {item['path']}: HTTP {file_response.status_code}")
                            except Exception as e:
                                print(f"  ✗ {item['path']}: {str(e)}")
                        
                        elif item["type"] == "dir":
                            # Recursively fetch directory
                            print(f"  Entering directory: {item['path']}")
                            await fetch_directory(item["path"])
                
                except Exception as e:
                    print(f"❌ Error fetching directory '{path}': {str(e)}")
                    import traceback
                    traceback.print_exc()
            
            # Start fetching from root
            await fetch_directory("")
            
            print(f"✓ Fetched {len(files)} files from {repo_full_name}")
            return files
    
    async def create_pull_request(
        self,
        repo_full_name: str,
        title: str,
        body: str,
        head_branch: str,
        base_branch: str = "main"
    ) -> Dict:
        """
        Create a pull request
        
        Args:
            repo_full_name: Repository in format "username/repo-name"
            title: PR title
            body: PR description
            head_branch: Branch with changes
            base_branch: Target branch (default: main)
        
        Returns:
            {"success": bool, "pr_url": str, "pr_number": int}
        """
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.base_url}/repos/{repo_full_name}/pulls",
                headers=self.headers,
                json={
                    "title": title,
                    "body": body,
                    "head": head_branch,
                    "base": base_branch
                },
                timeout=15.0
            )
            
            if response.status_code == 201:
                pr_data = response.json()
                return {
                    "success": True,
                    "pr_url": pr_data["html_url"],
                    "pr_number": pr_data["number"]
                }
            else:
                return {
                    "success": False,
                    "error": f"Failed to create PR: {response.text}"
                }
    
    async def push_coderabbit_config(self, repo_full_name: str, branch: str = "main") -> Dict:
        """
        Push .coderabbit.yaml configuration to repository for automated PR reviews.
        """
        import os
        config_path = os.path.join(
            os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
            "deployment",
            "coderabbit.yaml"
        )
        
        try:
            with open(config_path, "r") as f:
                config_content = f.read()
            
            result = await self.create_or_update_file(
                repo_full_name=repo_full_name,
                file_path=".coderabbit.yaml",
                content=config_content,
                message="Add CodeRabbit configuration for automated PR reviews",
                branch=branch
            )
            
            if result.get("success"):
                print(f"✓ Pushed .coderabbit.yaml to {repo_full_name}")
            else:
                print(f"✗ Failed to push .coderabbit.yaml: {result.get('error')}")
            
            return result
        except FileNotFoundError:
            print(f"✗ CodeRabbit config not found at {config_path}")
            return {"success": False, "error": "Config file not found"}
        except Exception as e:
            print(f"✗ Error pushing CodeRabbit config: {str(e)}")
            return {"success": False, "error": str(e)}
    
    async def push_github_workflows(self, repo_full_name: str, branch: str = "main") -> Dict:
        """
        Push GitHub Actions workflows for auto-merge and other automation.
        """
        import os
        workflow_path = os.path.join(
            os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
            "deployment",
            "github-auto-merge.yml"
        )
        
        try:
            with open(workflow_path, "r") as f:
                workflow_content = f.read()
            
            result = await self.create_or_update_file(
                repo_full_name=repo_full_name,
                file_path=".github/workflows/auto-merge.yml",
                content=workflow_content,
                message="Add auto-merge workflow for approved PRs",
                branch=branch
            )
            
            if result.get("success"):
                print(f"✓ Pushed auto-merge workflow to {repo_full_name}")
            else:
                print(f"✗ Failed to push auto-merge workflow: {result.get('error')}")
            
            return result
        except FileNotFoundError:
            print(f"✗ Auto-merge workflow not found at {workflow_path}")
            return {"success": False, "error": "Workflow file not found"}
        except Exception as e:
            print(f"✗ Error pushing auto-merge workflow: {str(e)}")
            return {"success": False, "error": str(e)}


# Singleton instance
github_client = GitHubAPIClient()
