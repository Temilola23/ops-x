"""
One-Prompt App Generation MCP Endpoint
Generates full applications using Gemini + GitHub + Vercel
"""

import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel
from typing import List, Dict, Optional
import asyncio

# Import our integrations
from integrations.gemini_code_generator import gemini_code_generator
from integrations.github_api import github_client  
from integrations.vercel_api import vercel_client

router = APIRouter()


class AppSpec(BaseModel):
    name: str
    entities: List[Dict]
    pages: List[str]
    requirements: List[str]


class AppBuildRequest(BaseModel):
    project_id: str
    spec: AppSpec


class AppBuildResponse(BaseModel):
    app_url: str
    components: List[Dict]
    api_schema: List[Dict]
    repo_url: Optional[str] = None
    status: str = "deployed"


# Store build status
build_status = {}


@router.post("/app/build", response_model=AppBuildResponse)
async def build_app(request: AppBuildRequest, background_tasks: BackgroundTasks):
    """
    Build an app from a single prompt using:
    1. Gemini for code generation
    2. GitHub for version control
    3. Vercel for deployment
    """
    
    project_id = request.project_id
    project_name = request.spec.name
    
    # Build the prompt from spec
    prompt_parts = [
        f"Build a web application called '{project_name}'.",
        f"Pages needed: {', '.join(request.spec.pages)}",
        f"Requirements: {', '.join(request.spec.requirements)}"
    ]
    
    if request.spec.entities:
        entities_desc = ', '.join([e['name'] for e in request.spec.entities])
        prompt_parts.append(f"Data entities: {entities_desc}")
    
    full_prompt = " ".join(prompt_parts)
    
    # Initialize build status
    build_status[project_id] = {
        "status": "generating_code",
        "progress": 10
    }
    
    try:
        # Step 1: Generate code with Gemini
        print(f"Generating code for: {project_name}")
        
        # Initialize generator if needed
        if gemini_code_generator is None:
            from integrations.gemini_code_generator import GeminiCodeGenerator
            try:
                generator = GeminiCodeGenerator()
            except ValueError as e:
                raise HTTPException(
                    status_code=500,
                    detail="Gemini API not configured. Set GEMINI_API_KEY environment variable."
                )
        else:
            generator = gemini_code_generator
        
        files = generator.generate_nextjs_app(project_name, full_prompt)
        
        if not files:
            raise HTTPException(
                status_code=500,
                detail="Failed to generate app code"
            )
        
        build_status[project_id]["status"] = "creating_repo"
        build_status[project_id]["progress"] = 30
        
        # Step 2: Create GitHub repository
        print(f"Creating GitHub repo: {project_name}")
        
        repo_name = project_name.lower().replace(' ', '-').replace('_', '-')
        repo_result = await github_client.create_repo(
            name=repo_name,
            description=f"Generated by OPS-X: {full_prompt[:100]}",
            private=False
        )
        
        if not repo_result["success"]:
            raise HTTPException(
                status_code=500,
                detail=f"Failed to create GitHub repo: {repo_result.get('error')}"
            )
        
        repo_full_name = repo_result["repo_name"]
        repo_url = repo_result["repo_url"]
        
        build_status[project_id]["status"] = "pushing_code"
        build_status[project_id]["progress"] = 50
        build_status[project_id]["repo_url"] = repo_url
        
        # Step 3: Push files to GitHub
        print(f"Pushing code to GitHub: {repo_full_name}")
        
        # Give GitHub a moment to initialize the repo
        await asyncio.sleep(2)
        
        push_result = await github_client.push_multiple_files(
            repo_full_name=repo_full_name,
            files=files,
            commit_message=f"Initial commit: Generated by OPS-X\n\n{full_prompt}",
            branch="main"
        )
        
        if not push_result["success"]:
            print(f" Warning: Some files failed to push: {push_result}")
        
        build_status[project_id]["status"] = "deploying"
        build_status[project_id]["progress"] = 70
        
        # Step 4: Deploy to Vercel
        print(f" Deploying to Vercel: {repo_name}")
        
        # Check if Vercel is configured
        if not vercel_client.token:
            # If no Vercel token, just return the GitHub repo
            print(" Vercel not configured, returning GitHub URL")
            
            return AppBuildResponse(
                app_url=repo_url,
                repo_url=repo_url,
                components=[
                    {"id": page.lower(), "type": "page"}
                    for page in request.spec.pages
                ],
                api_schema=[
                    {"path": "/api/data", "method": "GET"}
                ],
                status="code_generated"
            )
        
        # Create Vercel project
        project_result = await vercel_client.create_project(
            name=repo_name,
            github_repo=repo_full_name,
            framework="nextjs"
        )
        
        if not project_result["success"]:
            print(f" Vercel project creation failed: {project_result.get('error')}")
            # Return GitHub URL as fallback
            return AppBuildResponse(
                app_url=repo_url,
                repo_url=repo_url,
                components=[{"id": page.lower(), "type": "page"} for page in request.spec.pages],
                api_schema=[{"path": "/api/data", "method": "GET"}],
                status="code_generated"
            )
        
        # Trigger deployment
        deploy_result = await vercel_client.trigger_deployment(
            project_name=repo_name,
            github_repo=repo_full_name
        )
        
        build_status[project_id]["status"] = "deployed"
        build_status[project_id]["progress"] = 100
        
        if deploy_result["success"]:
            app_url = f"https://{deploy_result['url']}"
            
            print(f" Deployment complete: {app_url}")
            
            return AppBuildResponse(
                app_url=app_url,
                repo_url=repo_url,
                components=[
                    {"id": page.lower(), "type": "page"}
                    for page in request.spec.pages
                ],
                api_schema=[
                    {"path": "/api/data", "method": "GET"}
                ],
                status="deployed"
            )
        else:
            # Return GitHub URL as fallback
            return AppBuildResponse(
                app_url=repo_url,
                repo_url=repo_url,
                components=[{"id": page.lower(), "type": "page"} for page in request.spec.pages],
                api_schema=[{"path": "/api/data", "method": "GET"}],
                status="code_generated"
            )
    
    except Exception as e:
        print(f" Build error: {str(e)}")
        build_status[project_id]["status"] = "error"
        build_status[project_id]["error"] = str(e)
        
        raise HTTPException(
            status_code=500,
            detail=f"Build failed: {str(e)}"
        )


@router.get("/creao/status/{project_id}")
async def get_project_status(project_id: str):
    """Get build status of a project"""
    
    if project_id not in build_status:
        return {
            "project_id": project_id,
            "status": "not_found",
            "progress": 0
        }
    
    return {
        "project_id": project_id,
        **build_status[project_id]
    }
